// smartSVG implements a subset of the SVG standard to write good, well-formed svg in a simple fashion.
// Tags which encloses groups returns a new *SVG object which is possible to write to.
// Flush writes the coded svg to the writer provided.
package smartSVG

import (
	"bytes"
	"errors"
	"fmt"
	"handy"
	"io"
	"math"
)

const (
	svgInit = `<?xml version="1.0"?>
<!-- Generated by S-martVGo -->`
)

var defaultNamespace map[string]string

func init() {
	defaultNamespace = map[string]string{"xmlns": "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink"}
}

type Att map[string]string

// Holds one svg group with nodes of children inside group.
// data is used to hold data encapsuled within xml tag. If non-empty, then mids should be empty.
type SVG struct {
	tag      string
	a        Att
	data     string
	comments []string
	mids     []*SVG
}

// Create new SVG object to write to
func New(width, height int) *SVG {
	return &SVG{data: svgInit, mids: make([]*SVG, 0), comments: make([]string, 0), a: Att{"width": fmt.Sprint(width), "height": fmt.Sprint(height)}}
}

// Creates child group nested from s
func (s *SVG) newGroup(tag string, a Att) *SVG {
	g := SVG{tag: tag, a: make(Att, len(a))}

	// Copy attributes
	for k, v := range a {
		g.a[k] = v
	}

	s.mids = append(s.mids, &g)
	return &g
}

// Add svg group to outer svg group. Potentially dangerous, because it can break tree structure.
// Should add test to prevent cycle creation.
func (s *SVG) Add(svg *SVG) {
	s.mids = append(s.mids, svg)
}

// Encapsulate children of s within svg. Potentially dangerous, because it can break tree structure.
// Should add test to prevent cycle creation.
func (s *SVG) Insert(svg *SVG) *SVG {

	// Add children of s to children of svg
	svg.mids = append(svg.mids, s.mids...)

	// Substitute children of s with children of svg
	s.mids = s.mids[:0]
	s.mids = append(s.mids, svg)
	return svg
}

// Write svg file to w
func (s *SVG) Flush(w io.Writer) error {
	if s.tag != "" {
		return errors.New("I will only write from the outermost svg element")
	}
	s.tag = "svg"
	for k, v := range defaultNamespace {
		s.a[k] = v
	}

	var writeGroupPtr func(*SVG, int)
	writeGroup := func(s *SVG, level int) {
		tabs := bytes.Repeat([]byte("\t"), level)

		// Encode attributes to form att1="val1" att2="val2"... 
		buf := bytes.NewBuffer(nil)
		for k, v := range s.a {
			fmt.Fprintf(buf, `%s="%v" `, k, v)
		}

		atts := buf.Bytes()
		if len(atts) > 0 { // Remove superfluous space
			atts = atts[:len(atts)-1]
		}

		for _, v := range s.comments {
			w.Write([]byte("<!--" + v + "-->\n"))
		}

		w.Write(tabs)
		w.Write([]byte("<" + s.tag))
		if len(atts) != 0 {
			w.Write([]byte(" "))
		}
		w.Write(atts)

		switch {
		case len(s.mids) == 0 && len(s.data) == 0:
			w.Write([]byte(" />\n"))
		case len(s.mids) != 0:
			w.Write([]byte(">\n"))
			for _, v := range s.mids {
				writeGroupPtr(v, level+1)
			}
			w.Write(tabs)
			w.Write([]byte("</" + s.tag + ">\n"))
		default:
			w.Write([]byte(">" + s.data + "</" + s.tag + ">\n"))
		}
	}
	writeGroupPtr = writeGroup
	writeGroup(s, 0)
	return nil
}

// Add attributes to group
func (s *SVG) AddAtt(a Att, override bool) {
	for k, v := range a {
		var tmp string
		if !override {
			tmp = s.a[k]
			if tmp != "" {
				tmp += " "
			}
		}
		s.a[k] = tmp + v
	}
}

// Start svg group. Ref http://www.w3.org/TR/SVG11/struct.html#SVGElement
func (s *SVG) Start(width, height int, a Att) *SVG {
	g := s.newGroup("svg", a)
	g.a["width"] = fmt.Sprint(width)
	g.a["height"] = fmt.Sprint(height)
	return g
}

// Start svg group with viewbox. 
func (s *SVG) StartView(width, height, minX, minY, viewWidth, viewHeight int, a Att) *SVG {
	g := s.Start(width, height, a)
	g.a["viewBox"] = fmt.Sprintf("%d %d %d %d", minX, minY, viewWidth, viewHeight)
	return g
}

// Create symbol group
func (s *SVG) Symbol(id string, a Att) *SVG {
	g := s.newGroup("symbol", a)
	g.a["id"] = id
	return g
}

// Create symbol group with viewbox attribute
func (s *SVG) SymbolWithViewbox(id string, minX, minY, viewWidth, viewHeight int, a Att) *SVG {
	g := s.Symbol(id, a)
	g.a["viewBox"] = fmt.Sprintf("%d %d %d %d", minX, minY, viewWidth, viewHeight)
	return g
}

// Use element given in id
func (s *SVG) Use(id string, a Att) *SVG {
	g := s.newGroup("use", a)
	g.a["xlink:href"] = "#" + id
	return g
}

// Add comment to group
func (s *SVG) Comment(comment string) {
	s.comments = append(s.comments, comment)
}

// Create title
func (s *SVG) Title(title string) *SVG {
	g := s.newGroup("title", nil)
	g.data = title
	return g
}

// Create description
func (s *SVG) Desc(description string) *SVG {
	g := s.newGroup("desc", nil)
	g.data = description
	return g
}

// Create definitions
func (s *SVG) Def() *SVG {
	return s.newGroup("defs", nil)
}

// Create marker
func (s *SVG) Marker(id string, a Att) *SVG {
	g := s.newGroup("marker", a)
	g.a["id"] = id
	return g
}

// Create group
func (s *SVG) G(a Att) *SVG {
	return s.newGroup("g", a)
}

// Create group with id
func (s *SVG) GID(id string, a Att) *SVG {
	g := s.G(a)
	g.a["id"] = id
	return g
}

// Create group with translation of coordinate system
func (s *SVG) Translate(x, y int64) *SVG {
	a := Att{"transform": fmt.Sprintf("translate(%d, %d)", x, y)}
	return s.newGroup("g", a)
}

// Create group with scale of coordinate system
func (s *SVG) Scale(x, y float64) *SVG {
	a := Att{"transform": fmt.Sprintf("scale(%g, %g)", x, y)}
	return s.newGroup("g", a)
}

// Make translation attribute of coordinate system
func Translate(x, y int64) Att {
	return Att{"transform": fmt.Sprintf("translate(%d, %d)", x, y)}
}

// Make scale attribute of coordinate system
func Scale(x, y float64) Att {
	return Att{"transform": fmt.Sprintf("scale(%g, %g)", x, y)}
}

// Make object clickable
func (s *SVG) A(URL string) *SVG {
	g := SVG{tag: "a", a: Att{"xlink:href": URL, "xlink:show": "new"}}
	return s.Insert(&g)
}

// Draw circle
func (s *SVG) Circle(x, y, r int, a Att) *SVG {
	g := s.newGroup("circle", a)
	g.a["cx"] = fmt.Sprint(x)
	g.a["cy"] = fmt.Sprint(y)
	g.a["r"] = fmt.Sprint(r)
	return g
}

// Draw rectangle
func (s *SVG) Rect(x, y, width, height int, a Att) *SVG {
	g := s.newGroup("rect", a)
	g.a["x"] = fmt.Sprint(x)
	g.a["y"] = fmt.Sprint(y)
	g.a["width"] = fmt.Sprint(width)
	g.a["height"] = fmt.Sprint(height)
	return g
}

// Draw line
func (s *SVG) Line(x1, y1, x2, y2 int, a Att) *SVG {
	g := s.newGroup("line", a)
	g.a["x1"] = fmt.Sprint(x1)
	g.a["x2"] = fmt.Sprint(x2)
	g.a["y1"] = fmt.Sprint(y1)
	g.a["y2"] = fmt.Sprint(y2)
	return g
}

// Draw polyline
func (s *SVG) Polyline(d [][]float64, a Att) (error, *SVG) {
	switch {
	case len(d[0]) != len(d[1]):
		return errors.New("length of data pair is not equal"), nil
	case len(d[0]) == 0:
		return errors.New("length of data is zero"), nil
	}

	encloseData := func(x, y float64) string {
		return fmt.Sprintf("%f, %f ", x, y)
	}

	// Create formatted data plots
	data := make([]byte, 0, len(d[0]))
	for i := range d[0] {
		data = append(data, []byte(encloseData(d[0][i], d[1][i]))...)
	}

	// Draw the polyline
	g := s.newGroup("polyline", a)
	g.a["points"] = string(data)
	return nil, g
}

// Draw text
func (s *SVG) Text(x, y int, text string, a Att) *SVG {
	g := s.newGroup("text", a)
	g.data = text
	g.a["x"] = fmt.Sprint(x)
	g.a["y"] = fmt.Sprint(y)

	return g
}

// Write text on line from p1 to p2, with cntGrids values as given in vals.
// Prerequisites: vals[] is linear
func (s *SVG) Label(x1, y1, x2, y2 int, vals []float64, cntGrids int, a Att) {
	g := s.G(a)
	g.Desc("Label")
	xDiff := float64(x2 - x1)
	yDiff := float64(y2 - y1)
	angle := math.Abs(math.Atan(yDiff / xDiff))

	// Find increments
	valIncr := (vals[len(vals)-1] - vals[0]) / float64(cntGrids)
	xIncr := float64(xDiff) / float64(cntGrids) * math.Cos(angle)
	yIncr := float64(yDiff) / float64(cntGrids) * math.Sin(angle)

	// Start values
	val := vals[0]
	x := float64(x1)
	y := float64(y1)

	// Draw text
	for i := 0; i < cntGrids; i++ {
		g.Text(int(handy.Round(x, 0)), int(handy.Round(y, 0)), fmt.Sprintf("%.2f", val), nil)
		val += valIncr
		x += xIncr
		y += yIncr
	}
}

// Draw a grid with cntGrids horizontal and vertical lines
func (s *SVG) Grid(x, y, width, height, cntGrids int, a Att) {
	vLine := "vLine"
	hLine := "hLine"

	// Create group with defs
	g := s.G(a)
	g.Desc("Grid")
	d := g.Def()
	d.GID(vLine, nil).Line(0, 0, 0, height, nil)
	d.GID(hLine, nil).Line(0, 0, width, 0, nil)

	ix, iy := float64(x), float64(y)
	gridSizeX := float64(width) / float64(cntGrids)
	gridSizeY := float64(height) / float64(cntGrids)

	// Draw vertical and horizontal lines using the defined lines
	for i := 0; i < cntGrids; i++ {
		g.Use(vLine, map[string]string{"x": fmt.Sprintf("%.0f", ix)})
		g.Use(hLine, map[string]string{"y": fmt.Sprintf("%.0f", iy)})
		ix += gridSizeX
		iy += gridSizeY
	}
}

// Paint a diagram
func (s *SVG) Diagram(width, height int, d [][]float64) (error, *SVG) {

	for _, v := range d {
		if len(v) == 0 {
			return errors.New("Got empty data set"), nil
		}
	}

	last := d[0][0]
	for _, v := range d[0] {
		if v < last {
			return errors.New("Xvals is not sorted."), nil
		}
		last = v
	}
	if len(d[0]) != len(d[1]) {
		return errors.New("Got data pair with uneven length"), nil
	}

	textRoom := 70
	cntGrids := 10
	dWidth, dHeight := width-textRoom, height-textRoom
	v := s.Start(width, height, nil)
	v.AddAtt(Att{"id": "diagram"}, false)

	// Mark data on the axes
	v.Label(textRoom/2, height-textRoom, textRoom/2, 0, d[1], cntGrids, nil)
	v.Label(textRoom, height-2*textRoom/3, width, height-2*textRoom/3, d[0], cntGrids, nil)

	// Draw outer frame
	//defer v.Rect(0, 0, width, height, map[string]string{"stroke": "grey", "stroke-width": "1", "fill": "none"})

	// New group with plot, move to upper right corner
	g := v.G(Att{"transform": fmt.Sprintf("translate(%d, %d)", textRoom, 0)})
	g.Desc("Plot")
	dd := g.StartView(dWidth, dHeight, 0, 0, dWidth, dHeight, nil)
	cartesian := dd.Translate(0, int64(dHeight))
	cartesian.AddAtt(Scale(1, -1), false)
	// Draw inner frame almost last
	defer cartesian.Rect(0, 0, dWidth, dHeight, Att{"stroke": "grey", "stroke-width": "3", "fill": "none"})

	cartesian.Grid(0, 0, dWidth, dHeight, cntGrids, Att{"stroke": "black", "stroke-width": "1"})

	// Finds the scales and shift of data
	resize := func(vals []float64, length int) (scale, shift float64) {
		min, _ := handy.Min(vals) // ignoring err because data has already been tested
		max, _ := handy.Max(vals)
		scale = float64(length) / (max - min)
		shift = -min * scale
		return
	}
	xScale, xShift := resize(d[0], dWidth)
	yScale, yShift := resize(d[1], dHeight)

	// Scales and shifts the plot
	plot := cartesian.Translate(int64(handy.Round(xShift, 0)), int64(handy.Round(yShift, 0)))
	plot.AddAtt(Scale(xScale, yScale), false)

	// Create marker inside defs to be used with plot
	plot.Def().Marker("polyline-midmarker", Att{"style": "overflow:visible"}).Circle(0, 0, 5, Att{"fill": "none", "stroke": "black"})

	// Draws the plot
	err, _ := plot.Polyline(d, Att{"fill": "none", "stroke": "red", "vector-effect": "non-scaling-stroke", "marker-mid": "url(#polyline-midmarker)"})
	return err, plot
}

// Test to prevent adding plot to previous plot not working?
func (s *SVG) AddPlot(d [][]float64, a Att) (error, *SVG) {
	for _, g := range s.mids {
		if g.tag == "polyline" {
			err, plot := s.Polyline(d, map[string]string{"vector-effect": "non-scaling-stroke"})
			plot.AddAtt(a, true)
			return err, plot
		}
	}
	return errors.New("Could not find previous group with polyline"), nil
}
