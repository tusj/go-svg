// smartSVG implements a subset of the SVG standard to write good, well-formed svg in a simple fashion.
// Tags which encloses groups returns a new *SVG object which is possible to write to.
// Flush writes the coded svg to the writer provided.
package smartSVG

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"marketExchanger/helpers"
	"math"
)

const (
	svgInit = `<?xml version="1.0"?>
<!-- Generated by S-martVGo -->`
)

var defaultNamespace map[string]string

func init() {
	defaultNamespace = map[string]string{"xmlns": "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink"}
}

// Holds one svg group with nodes of children inside group.
type SVG struct {
	tag      string
	atts     map[string]string
	data     string
	comments []string
	mids     []*SVG
}

// Creates child group nested from s
func (s *SVG) newGroup(tag string, attributes map[string]string) *SVG {
	g := SVG{tag: tag, atts: make(map[string]string, len(attributes))}

	// Copy map
	for k, v := range attributes {
		g.atts[k] = v
	}

	s.mids = append(s.mids, &g)
	return &g
}

// Create new SVG object to write to
func New(width, height int) *SVG {
	return &SVG{data: svgInit, mids: make([]*SVG, 0), comments: make([]string, 0), atts: map[string]string{"width": fmt.Sprint(width), "height": fmt.Sprint(height)}}
}

// Add svg group to outer svg group
func (s *SVG) Add(svg *SVG) {
	s.mids = append(s.mids, svg)
}

// Write svg file to w
func (s *SVG) Flush(w io.Writer) error {
	if s.tag != "" {
		return errors.New("I will only write from the outermost svg element")
	}
	s.tag = "svg"
	for k, v := range defaultNamespace {
		s.atts[k] = v
	}

	var writeGroupPtr func(*SVG, int)
	writeGroup := func(s *SVG, level int) {
		tabs := bytes.Repeat([]byte("\t"), level)

		// Encode attributes to form att1="val1" att2="val2"... 
		buf := bytes.NewBuffer(nil)
		for k, v := range s.atts {
			fmt.Fprintf(buf, `%s="%v" `, k, v)
		}

		atts := buf.Bytes()
		if len(atts) > 0 { // Remove superfluous space
			atts = atts[:len(atts)-1]
		}

		for _, v := range s.comments {
			w.Write([]byte("<!--" + v + "-->\n"))
		}
		
		w.Write(tabs)
		w.Write([]byte("<" + s.tag))
		if len(atts) != 0 {
			w.Write([]byte(" "))
		}
		w.Write(atts)
		
		switch {
		case len(s.mids) == 0 && len(s.data) == 0:
			w.Write([]byte(" />\n"))
		case len(s.mids) != 0:
			w.Write([]byte(">\n"))
			for _, v := range s.mids {
				writeGroupPtr(v, level+1)
			}
			w.Write(tabs)
			w.Write([]byte("</" + s.tag + ">\n"))
		default:
			w.Write([]byte(">" + s.data + "</" + s.tag + ">\n"))
		}
	}
	writeGroupPtr = writeGroup
	writeGroup(s, 0)
	return nil
}


// Add attributes to group
func (s *SVG) AddAtt(atts map[string]string) {
	for k, v := range atts {
		tmp := s.atts[k]
		if tmp != "" {
			tmp += " "
		}
		s.atts[k] = tmp + v
	}
}

// Start svg group. Ref http://www.w3.org/TR/SVG11/struct.html#SVGElement
func (s *SVG) Start(width, height int, atts map[string]string) *SVG {
	g := s.newGroup("svg", atts)
	g.atts["width"] = fmt.Sprint(width)
	g.atts["height"] = fmt.Sprint(height)
	return g
}

// Start svg group with viewbox. 
func (s *SVG) StartView(width, height, minX, minY, viewWidth, viewHeight int, atts map[string]string) *SVG {
	g := s.Start(width, height, atts)
	g.atts["viewBox"] = fmt.Sprintf("%d %d %d %d", minX, minY, viewWidth, viewHeight)
	return g
}

// Create symbol group
func (s *SVG) Symbol(id string, atts map[string]string) *SVG {
	g := s.newGroup("symbol", atts)
	g.atts["id"] = id
	return g
}


// Create symbol group with viewbox attribute
func (s *SVG) SymbolWithViewbox(id string, minX, minY, viewWidth, viewHeight int, atts map[string]string) *SVG {
	g := s.Symbol(id, atts)
	g.atts["viewBox"] = fmt.Sprintf("%d %d %d %d", minX, minY, viewWidth, viewHeight)
	return g
}

// Use element given in id
func (s *SVG) Use(id string, atts map[string]string) *SVG {
	g := s.newGroup("use", atts)
	g.atts["xlink:href"] = "#" + id
	return g
}

// Add comment to group
func (s *SVG) Comment(comment string) {
	s.comments = append(s.comments, comment)
}

// Create title
func (s *SVG) Title(title string) *SVG {
	g := s.newGroup("title", nil)
	g.data = title
	return g
}

// Create description
func (s *SVG) Desc(description string) *SVG {
	g := s.newGroup("desc", nil)
	g.data = description
	return g
}

// Create definitions
func (s *SVG) Def() *SVG {
	return s.newGroup("defs", nil)
}

// Create marker
func (s *SVG) Marker(id string, atts map[string]string) *SVG {
	g := s.newGroup("marker", atts)
	g.atts["id"] = id
	return g
}

// Create group
func (s *SVG) G(atts map[string]string) *SVG {
	return s.newGroup("g", atts)
}

// Create group with id
func (s *SVG) GID(id string, atts map[string]string) *SVG {
	g := s.G(atts)
	g.atts["id"] = id
	return g
}

// Create group with translation of coordinate system
func (s *SVG) Translate(x, y int64) *SVG {
	atts := map[string]string{"transform": fmt.Sprintf("translate(%d, %d)", x, y)}
	return s.newGroup("g", atts)
}

// Create group with scale of coordinate system
func (s *SVG) Scale(x, y float64) *SVG {
	atts := map[string]string{"transform": fmt.Sprintf("scale(%g, %g)", x, y)}
	return s.newGroup("g", atts)
}

// Make translation attribute of coordinate system
func Translate(x, y int64) map[string]string {
	return map[string]string{"transform": fmt.Sprintf("translate(%d, %d)", x, y)}
}

// Make scale attribute of coordinate system
func Scale(x, y float64) map[string]string {
	return map[string]string{"transform": fmt.Sprintf("scale(%g, %g)", x, y)}
}

// Draw circle
func (s *SVG) Circle(x, y, r int, atts map[string]string) *SVG {
	g := s.newGroup("circle", atts)
	g.atts["cx"] = fmt.Sprint(x)
	g.atts["cy"] = fmt.Sprint(y)
	g.atts["r"] = fmt.Sprint(r)
	return g
}

// Draw rectangle
func (s *SVG) Rect(x, y, width, height int, atts map[string]string) *SVG {
	g := s.newGroup("rect", atts)
	g.atts["x"] = fmt.Sprint(x)
	g.atts["y"] = fmt.Sprint(y)
	g.atts["width"] = fmt.Sprint(width)
	g.atts["height"] = fmt.Sprint(height)
	return g
}

// Draw line
func (s *SVG) Line(x1, y1, x2, y2 int, atts map[string]string) *SVG {
	g := s.newGroup("line", atts)
	g.atts["x1"] = fmt.Sprint(x1)
	g.atts["x2"] = fmt.Sprint(x2)
	g.atts["y1"] = fmt.Sprint(y1)
	g.atts["y2"] = fmt.Sprint(y2)
	return g
}

// Draw polyline
func (s *SVG) Polyline(x, y []float64, atts map[string]string) (error, *SVG) {
	switch {
	case len(x) != len(y):
		return errors.New("length of x and y data is not equal"), nil
	case len(x) == 0:
		return errors.New("length of x is zero"), nil
	}

	encloseData := func(x, y float64) string {
		return fmt.Sprintf("%f, %f ", x, y)
	}
	
	// Create formatted data plots
	data := make([]byte, 0, len(x)*4)
	for i := range x {
		data = append(data, []byte(encloseData(x[i], y[i]))...)
	}
	
	// Draw the polyline
	g := s.newGroup("polyline", atts)
	g.atts["points"] = string(data)
	return nil, g
}

// Draw text
func (s *SVG) Text(x, y int, text string, atts map[string]string) *SVG {
	g := s.newGroup("text", atts)
	g.data = text
	g.atts["x"] = fmt.Sprint(x)
	g.atts["y"] = fmt.Sprint(y)

	return g
}

const (
	verticalShift = iota
	horizontalShift
)

func findShiftAndScale(i []float64, length int) (scale, shift float64, err error) {
	switch {
	case i == nil:
		err = errors.New("Received invalid argument: Argument is nil")
	case len(i) == 0:
		err = errors.New("Received invalid argument: Argument is zero")
	}
	if err != nil {
		return
	}
	Max, Min := helpers.Max(i), helpers.Min(i)
	
	scale = float64(length*90/100) / (Max[0] - Min[0])
	shift = -Min[0]
	return
}

func shiftAndScale(i []float64, shift, scale float64) (scaled []int) {
	scaled = make([]int, len(i))

	for ind, v := range i {
		scaled[ind] = int(helpers.Round((v+shift)*scale, 0))
	}

	return
}

// Write text on line from p1 to p2, with cntGrids values as given in vals.
// Prerequisites: vals[] is linear
func (s *SVG) Label(x1, y1, x2, y2 int, vals []float64, cntGrids int, atts map[string]string) {
	g := s.GID("label", atts)
	xDiff := float64(x2 - x1)
	yDiff := float64(y2 - y1)
	angle := math.Atan(yDiff / xDiff)
	
	// Find increments
	valIncr := (vals[len(vals)-1] - vals[0]) / float64(cntGrids)
	xIncr := float64(xDiff) / float64(cntGrids) * math.Cos(angle)
	yIncr := float64(yDiff) / float64(cntGrids) * math.Sin(angle)
	
	// Start values
	val := vals[0]
	x := float64(x1)
	y := float64(y1)
	
	// Draw text
	for i := 0; i < cntGrids; i++ {
		g.Text(int(helpers.Round(x, 0)), int(helpers.Round(y, 0)), fmt.Sprintf("%.2f", val), nil)
		val += valIncr
		x += xIncr
		y += yIncr
	}
}

// Draw a grid with cntGrids horizontal and vertical lines
func (s *SVG) Grid(x, y, width, height, cntGrids int, atts map[string]string) {
	vLine := "vLine"
	hLine := "hLine"
	
	
	// Create group with defs
	g := s.GID("grid", atts)
	d := g.Def()
	d.GID(vLine, nil).Line(0, 0, 0, height, nil)
	d.GID(hLine, nil).Line(0, 0, width, 0, nil)


	
	ix, iy := float64(x), float64(y)
	gridSizeX := float64(width) / float64(cntGrids)
	gridSizeY := float64(height) / float64(cntGrids)
	
	
	// Draw vertical and horizontal lines using the defined lines
	for i := 0; i < cntGrids; i++ {
		g.Use(vLine, map[string]string{"x": fmt.Sprintf("%.0f", ix)})
		g.Use(hLine, map[string]string{"y": fmt.Sprintf("%.0f", iy)})
		ix += gridSizeX
		iy += gridSizeY
	}
}

// Paint a diagram
func (s *SVG) Diagram(width, height int, xVals, yVals []float64) (error, *SVG) {
	minWidth, minHeight := 100, 100
	
	last := xVals[0]
	for _, v := range xVals {
		if v < last {
			return errors.New("Xvals is not sorted."), nil
		}
		last = v
	}
	switch {
	case len(xVals) != len(yVals):
		return errors.New("Got data pair with inconsistent length. Len x: " + fmt.Sprint(len(xVals)) + "\tlen y: " + fmt.Sprint(len(xVals))), nil
	case width < 100:
		return errors.New("Width is below minimum width, which is " + fmt.Sprint(minWidth)), nil
	case height < 100:
		return errors.New("Height is below minimum height, which is " + fmt.Sprint(minHeight)), nil
	}

	textRoom := 70
	cntGrids := 10
	dWidth, dHeight := width-textRoom, height-textRoom
	v := s.Start(width, height, nil)
	v.AddAtt(map[string]string{"id": "diagram"})
	
	// Mark data on the axes
	v.Label(textRoom/2, 0, textRoom/2, height - textRoom, yVals, cntGrids, nil)
	v.Label(textRoom, height - 2 * textRoom / 3, width, height- 2 * textRoom / 3, xVals, cntGrids, nil)
	
	// Draw outer frame
	defer v.Rect(0, 0, width, height, map[string]string{"stroke": "grey", "stroke-width": "1", "fill": "none"})
	
	// New group with plot, move to upper right corner
	g := v.GID("plot", map[string]string{"transform": fmt.Sprintf("translate(%d, %d)", textRoom, 0)})
	d := g.StartView(dWidth, dHeight, 0, 0, dWidth, dHeight, nil)
	// Draw inner frame almost last
	defer d.Rect(0, 0, dWidth, dHeight, map[string]string{"stroke": "grey", "stroke-width": "3", "fill": "none"})
	
	d.Grid(0, 0, dWidth, dHeight, cntGrids, map[string]string{"stroke": "grey", "stroke-width": "1"})
	
	
	// Finds the scales and shift of data
	resize := func(vals []float64, length int) (scale, shift float64) {
		min := helpers.Min(vals)[0]
		scale = float64(length) / (helpers.Max(vals)[0] - min)
		shift = -min * scale
		return
	}
	xScale, xShift := resize(xVals, dWidth)
	yScale, yShift := resize(yVals, dHeight)
	
	// Scales and shifts the plot
	plot := d.Translate(int64(helpers.Round(xShift, 0)), int64(helpers.Round(yShift, 0)))
	plot.AddAtt(Scale(xScale, yScale))
	
	// Create marker inside defs to be used with plot
	plot.Def().Marker("polyline-midmarker", map[string]string{"style": "overflow:visible"}).Circle(0, 0, 2, map[string]string{"fill": "blue", "stroke": "black"})

	// Draws the plot
	err, _ := plot.Polyline(xVals, yVals, map[string]string{"fill": "none", "stroke": "red", "stroke-width": fmt.Sprintf("%.5f", 1 / yScale), "marker-mid": "url(#polyline-midmarker)"})
	return err, plot
}

func (s *SVG) AddPlot(xVals, yVals []float64) (error, *SVG) {
	for _, g := range s.mids {
		if g.tag == "polyline" {
			return s.Polyline(xVals, yVals, g.atts)
		}
	}
	return errors.New("Could not find previous group with polyline"), nil
}