// smartSVG implements svg helper functions to write good, well-formed svg in a simple fashion.
// Tags which encloses groups returns a new *SVG object which is possible to write to.
// Flush writes the coded svg to the writer provided.
package smartSVG

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"marketExchanger/helpers"
	"strconv"
)

const (
	svgInit = `<?xml version="1.0"?>
<!-- Generated by S-martVGo -->`
)

var defaultNamespace map[string]string

func init() {
	defaultNamespace = map[string]string{"xmlns": "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink"}
}

// Tags
const (
	svg       = "svg"
	sym       = "sym"
	use       = "use"
	title     = "title"
	desc      = "desc"
	marker    = "marker"
	defs      = "defs"
	g         = "g"
	transform = "transform"
	circle    = "circle"
	rect      = "rect"
	line      = "line"
	polyline  = "polyline"
	text      = "text"
)

// Atts
const (
	x      = "x"
	y      = "y"
	rad    = "r"
	width  = "width"
	height = "height"
	points = "points"
)

// Holds one svg group with nodes of children inside group.
type SVG struct {
	tag      string
	atts     map[string]string
	data     string
	comments []string
	mids     []*SVG
}

// Creates child group nested from s
func (s *SVG) newGroup(tag string, attributes map[string]string) *SVG {
	g := SVG{tag: tag, atts: make(map[string]string, len(attributes))}

	// Copy map
	for k, v := range attributes {
		g.atts[k] = v
	}

	s.mids = append(s.mids, &g)
	return &g
}

// Create new SVG object to write to
func New(width, height int) *SVG {
	return &SVG{data: svgInit, mids: make([]*SVG, 0), comments: make([]string, 0), atts: map[string]string{"width": fmt.Sprint(width), "height": fmt.Sprint(height)}}
}

// Flush svg in order to write the SVG
func (s *SVG) Flush(w io.Writer) error {
	if s.tag != "" {
		return errors.New("I will only write from the outermost svg element")
	}
	s.tag = "svg"
	for k, v := range defaultNamespace {
		s.atts[k] = v
	}

	var writeGroupPtr func(*SVG, int)
	writeGroup := func(s *SVG, level int) {
		tabs := bytes.Repeat([]byte("\t"), level)

		// Encode attributes to form att1="val1" att2="val2"... 
		buf := bytes.NewBuffer(nil)
		for k, v := range s.atts {
			fmt.Fprintf(buf, `%s="%v" `, k, v)
		}

		b := buf.Bytes()
		if len(b) > 0 { // Remove superfluous space
			b = b[:len(b)-1]
		}

		wb := func(str string) {
			w.Write(tabs)
			w.Write([]byte(str))
			w.Write(b)
		}

		for _, v := range s.comments {
			w.Write([]byte("<!--" + v + "-->\n"))
		}

		switch {
		case len(s.mids) == 0 && len(s.data) == 0:
			wb("<" + s.tag + " ")
			w.Write([]byte(" />\n"))
		case len(s.mids) != 0:
			wb("<" + s.tag + " ")
			w.Write([]byte(">\n"))
			for _, v := range s.mids {
				writeGroupPtr(v, level+1)
			}
			w.Write(tabs)
			w.Write([]byte("</" + s.tag + ">\n"))
		default:
			wb("<" + s.tag + " ")
			w.Write([]byte(">" + s.data + "</" + s.tag + ">\n"))
		}
	}
	writeGroupPtr = writeGroup
	writeGroup(s, 0)
	return nil
}

func (s *SVG) AddAttributes(atts map[string]string) {
	for k, v := range atts {
		s.atts[k] = v
	}
}

// Write Start. Ref http://www.w3.org/TR/SVG11/struct.html#SVGElement
func (s *SVG) Start(width, height int, atts map[string]string) *SVG {
	g := s.newGroup(svg, atts)
	g.atts["width"] = fmt.Sprint(width)
	g.atts["height"] = fmt.Sprint(height)
	return g
}

// Start with viewbox. 
func (s *SVG) StartView(width, height, minX, minY, viewWidth, viewHeight int, atts map[string]string) *SVG {
	g := s.Start(width, height, atts)
	g.atts["viewBox"] = fmt.Sprintf("%d %d %d %d", minX, minY, viewWidth, viewHeight)
	return g
}

func (s *SVG) Symbol(id string, atts map[string]string) *SVG {
	g := s.newGroup(sym, atts)
	g.atts["id"] = id
	return g
}

func (s *SVG) SymbolWithViewbox(id string, minX, minY, viewWidth, viewHeight int, atts map[string]string) *SVG {
	g := s.Symbol(id, atts)
	g["viewBox"] = fmt.Sprintf("%d %d %d %d", minX, minY, viewWidth, viewHeight)
	return g
}

func (s *SVG) Use(id string, atts map[string]string) {
	g := s.newGroup(use, atts)
	g.atts["xlink:href"] = "#" + id
}

func (s *SVG) Comment(comment string) {
	s.comments = append(s.comments, comment)
}

// Create title
func (s *SVG) Title(t string) {
	g := s.newGroup(title, nil)
	g.data = t
}

// Create description
func (s *SVG) Desc(d string) {
	g := s.newGroup(desc, nil)
	g.data = d
}

// Create definitions
func (s *SVG) Def() *SVG {
	return s.newGroup(defs, nil)
}

// Create marker
func (s *SVG) Marker(id string, atts map[string]string) *SVG {
	g := s.newGroup(marker, atts)
	g.atts["id"] = id
	return g
}

// Create group
func (s *SVG) G(atts map[string]string) *SVG {
	return s.newGroup(g, atts)
}

// Create group with id
func (s *SVG) GID(id string, atts map[string]string) *SVG {
	g := s.G(atts)
	g.atts["id"] = id
	return g
}

// Translate coordinate system
func (s *SVG) Translate(x, y int) *SVG {
	atts := map[string]string{"transform": fmt.Sprintf("translate(%d, %d)", x, y)}
	return s.newGroup(g, atts)
}

// Scale coordinate system
func (s *SVG) Scale(x, y int) *SVG {
	atts := map[string]string{"transform": fmt.Sprintf("scale(%d, %d)", x, y)}
	return s.newGroup(g, atts)
}

// Draw circle
func (s *SVG) Circle(x, y, r int, atts map[string]string) {
	g := s.newGroup(circle, atts)
	g.atts["cx"] = fmt.Sprint(x)
	g.atts["cy"] = fmt.Sprint(y)
	g.atts["r"] = fmt.Sprint(r)
}

// Draw rectangle
func (s *SVG) Rect(x, y, width, height int, atts map[string]string) {
	g := s.newGroup(rect, atts)
	g.atts["x"] = fmt.Sprint(x)
	g.atts["y"] = fmt.Sprint(y)
	g.atts["width"] = fmt.Sprint(width)
	g.atts["height"] = fmt.Sprint(height)
}

// Draw line
func (s *SVG) Line(x1, y1, x2, y2 int, atts map[string]string) {
	g := s.newGroup(rect, atts)
	g.atts["x1"] = fmt.Sprint(x1)
	g.atts["x2"] = fmt.Sprint(x2)
	g.atts["y1"] = fmt.Sprint(y1)
	g.atts["y2"] = fmt.Sprint(y2)
}

// Draw polyline
func (s *SVG) PolyLine(x, y []int, atts map[string]string) error {
	switch {
	case len(x) != len(y):
		return errors.New("length of x and y data is not equal")
	case len(x) == 0:
		return errors.New("length of x is zero")
	}

	encloseData := func(x, y int) string {
		return fmt.Sprintf("%d,%d ", x, y)
	}

	data := make([]byte, 0, len(x)*4)
	for i := range x {
		data = append(data, []byte(encloseData(x[i], y[i]))...)
	}

	g := s.newGroup(polyline, atts)
	g.atts["points"] = string(data)
	return nil
}

// Draw text
func (s *SVG) Text(x, y int, fontFamily, fontSize, fill string, atts map[string]string) {
	g := s.newGroup(text, atts)
	g.atts["x"] = fmt.Sprint(x)
	g.atts["y"] = fmt.Sprint(y)
	g.atts["font-family"] = fontFamily
	g.atts["font-size"] = fontSize
	g.atts["fill"] = fill
}

const (
	verticalShift = iota
	horizontalShift
)

func findShiftAndScale(i []float64, length int) (scale, shift float64, err error) {
	switch {
	case i == nil:
		err = errors.New("Received invalid argument: Argument is nil")
	case len(i) == 0:
		err = errors.New("Received invalid argument: Argument is zero")
	}
	if err != nil {
		return
	}
	Max, Min := helpers.Max(i), helpers.Min(i)

	scale = float64(length*90/100) / (Max[0] - Min[0])
	shift = -Min[0]
	return
}

func shiftAndScale(i []float64, shift, scale float64) (scaled []int) {
	scaled = make([]int, len(i))

	for ind, v := range i {
		scaled[ind] = int(helpers.Round((v+shift)*scale, 0))
	}

	return
}

// Paint a diagram. Prerequisites: X must be sorted.
func (s *SVG) Diagram(width, height int, vals ...[2][]float64) (err error) {

	if len(vals) == 0 {
		return errors.New("Got no vals")
	}

	for i, xyPair := range vals {
		switch {
		case len(xyPair[0]) == 0:
			return errors.New("Got no x coordinates")
		case len(xyPair[1]) == 0:
			return errors.New("Got no y coordinates")
		case len(xyPair[1]) != len(xyPair[0]):
			return errors.New("Got data pair with inconsistent length. Len x: " + strconv.Itoa(len(xyPair[0])) + "\tlen y: " + strconv.Itoa(len(xyPair[1])) + " at number " + strconv.Itoa(i))
		}
	}

	minWidth, minHeight := 100, 100

	switch {
	case width < 100:
		return errors.New("Width is below minimum width, which is " + strconv.Itoa(minWidth))
	case height < 100:
		return errors.New("Height is below minimum height, which is " + strconv.Itoa(minHeight))
	}

	v := s.StartView(width, height, 0, 0, width, height, nil)
	d := v.Def()
	s := d.Symbol()
	rad := 10
	v.Circle(0, 0, rad, map[string]string{"fill": "red"})
	v.Circle(width, 0, rad*2, map[string]string{"fill": "blue"})
	v.Circle(width, height, rad*3, map[string]string{"fill": "green"})
	v.Circle(0, height, rad*4, map[string]string{"fill": Yellowgreen})
	defer v.Rect(0, 0, width, height, map[string]string{"stroke": "green", "stroke-width": "1", "fill": "none"})
	// Draw values and value lines

	textRoom := 50
	dWidth, dHeight := width-textRoom, height-textRoom
	d := v.StartView(dWidth, dHeight, 0, 0, dWidth, dHeight, nil)
	d.Def().Marker("polyline-midmarker", map[string]string{"style": "overflow:visible", "fill": "black"}).Circle(0, 0, 2, map[string]string{"fill": "none", "stroke": "black"})
	d.Grid(0, 0, dWidth, dHeight, textRoom, map[string]string{"stroke": "black", "stroke-width": "1"})

	defer d.Rect(0, 0, dWidth, dHeight, map[string]string{"stroke": "red", "stroke-width": "3", "fill": "none"})

	//xShifts := make([]float64, len(vals))
	//yShifts := make([]float64, len(vals))
	//xScales := make([]float64, len(vals))
	//yScales := make([]float64, len(vals))

	//for i, xyPair := range vals {
	//xShifts[i], xScales[i], err = findShiftAndScale(xyPair[0], width)
	//if err != nil {
	//return
	//}

	//yShifts[i], yScales[i], err = findShiftAndScale(xyPair[1], height)
	//if err != nil {
	//return
	//}
	//}

	//scales := helpers.Min(xScales, yScales)
	//shifts := helpers.Min(xShifts, yShifts)

	//l := d.Scale(1, -1).G(`fill="none"`)
	//for _, xyPair := range vals {
	//xScales := shiftAndScale(xyPair[0], scales[0],shifts[0])
	//yScales := shiftAndScale(xyPair[1], scales[1], shifts[1])
	//l.PolyLine(xScales, yScales)
	//}
	return nil
}

func (s *SVG) Grid(x, y, width, height, gridSize int, atts map[string]string) {
	g := s.GID("grid", atts)
	d := g.Def()

	vLine := "vLine"
	hLine := "hLine"

	d.Line(0, 0, width, 0, map[string]string{"id": hLine})
	d.Line(0, 0, 0, height, map[string]string{"id": vLine})

	for ix := x; ix <= x+width; ix += gridSize {
		g.Use(vLine, map[string]string{"x1": fmt.Sprint(ix)})
	}

	for iy := y; iy <= y+height; iy += gridSize {
		g.Use(hLine, map[string]string{"y1": fmt.Sprint(iy)})
	}
}

const (
	Aliceblue            = "aliceblue"            // rgb(240, 248, 255)
	Antiquewhite         = "antiquewhite"         // rgb(250, 235, 215)
	Aqua                 = "aqua"                 // rgb(0, 255, 255)
	Aquamarine           = "aquamarine"           // rgb(127, 255, 212)
	Azure                = "azure"                // rgb(240, 255, 255)
	Beige                = "beige"                // rgb(245, 245, 220)
	Bisque               = "bisque"               // rgb(255, 228, 196)
	Black                = "black"                // rgb(0, 0, 0)
	Blanchedalmond       = "blanchedalmond"       // rgb(255, 235, 205)
	Blue                 = "blue"                 // rgb(0, 0, 255)
	Blueviolet           = "blueviolet"           // rgb(138, 43, 226)
	Brown                = "brown"                // rgb(165, 42, 42)
	Burlywood            = "burlywood"            // rgb(222, 184, 135)
	Cadetblue            = "cadetblue"            // rgb(95, 158, 160)
	Chartreuse           = "chartreuse"           // rgb(127, 255, 0)
	Chocolate            = "chocolate"            // rgb(210, 105, 30)
	Coral                = "coral"                // rgb(255, 127, 80)
	Cornflowerblue       = "cornflowerblue"       // rgb(100, 149, 237)
	Cornsilk             = "cornsilk"             // rgb(255, 248, 220)
	Crimson              = "crimson"              // rgb(220, 20, 60)
	Cyan                 = "cyan"                 // rgb(0, 255, 255)
	Darkblue             = "darkblue"             // rgb(0, 0, 139)
	Darkcyan             = "darkcyan"             // rgb(0, 139, 139)
	Darkgoldenrod        = "darkgoldenrod"        // rgb(184, 134, 11)
	Darkgray             = "darkgray"             // rgb(169, 169, 169)
	Darkgreen            = "darkgreen"            // rgb(0, 100, 0)
	Darkgrey             = "darkgrey"             // rgb(169, 169, 169)
	Darkkhaki            = "darkkhaki"            // rgb(189, 183, 107)
	Darkmagenta          = "darkmagenta"          // rgb(139, 0, 139)
	Darkolivegreen       = "darkolivegreen"       // rgb(85, 107, 47)
	Darkorange           = "darkorange"           // rgb(255, 140, 0)
	Darkorchid           = "darkorchid"           // rgb(153, 50, 204)
	Darkred              = "darkred"              // rgb(139, 0, 0)
	Darksalmon           = "darksalmon"           // rgb(233, 150, 122)
	Darkseagreen         = "darkseagreen"         // rgb(143, 188, 143)
	Darkslateblue        = "darkslateblue"        // rgb(72, 61, 139)
	Darkslategray        = "darkslategray"        // rgb(47, 79, 79)
	Darkslategrey        = "darkslategrey"        // rgb(47, 79, 79)
	Darkturquoise        = "darkturquoise"        // rgb(0, 206, 209)
	Darkviolet           = "darkviolet"           // rgb(148, 0, 211)
	Deeppink             = "deeppink"             // rgb(255, 20, 147)
	Deepskyblue          = "deepskyblue"          // rgb(0, 191, 255)
	Dimgray              = "dimgray"              // rgb(105, 105, 105)
	Dodgerblue           = "dodgerblue"           // rgb(30, 144, 255)
	Firebrick            = "firebrick"            // rgb(178, 34, 34)
	Floralwhite          = "floralwhite"          // rgb(255, 250, 240)
	Forestgreen          = "forestgreen"          // rgb(34, 139, 34)
	Fuchsia              = "fuchsia"              // rgb(255, 0, 255)
	Gainsboro            = "gainsboro"            // rgb(220, 220, 220)
	Ghostwhite           = "ghostwhite"           // rgb(248, 248, 255)
	Gold                 = "gold"                 // rgb(255, 215, 0)
	Goldenrod            = "goldenrod"            // rgb(218, 165, 32)
	Gray                 = "gray"                 // rgb(128, 128, 128)
	Grey                 = "grey"                 // rgb(128, 128, 128)
	Green                = "green"                // rgb(0, 128, 0)
	Greenyellow          = "greenyellow"          // rgb(173, 255, 47)
	Honeydew             = "honeydew"             // rgb(240, 255, 240)
	Hotpink              = "hotpink"              // rgb(255, 105, 180)
	Indianred            = "indianred"            // rgb(205, 92, 92)
	Indigo               = "indigo"               // rgb(75, 0, 130)
	Ivory                = "ivory"                // rgb(255, 255, 240)
	Khaki                = "khaki"                // rgb(240, 230, 140)
	Lavender             = "lavender"             // rgb(230, 230, 250)
	Lavenderblush        = "lavenderblush"        // rgb(255, 240, 245)
	Lawngreen            = "lawngreen"            // rgb(124, 252, 0)
	Lemonchiffon         = "lemonchiffon"         // rgb(255, 250, 205)
	Lightblue            = "lightblue"            // rgb(173, 216, 230)
	Lightcoral           = "lightcoral"           // rgb(240, 128, 128)
	Lightcyan            = "lightcyan"            // rgb(224, 255, 255)
	Lightgoldenrodyellow = "lightgoldenrodyellow" // rgb(250, 250, 210)
	Lightgray            = "lightgray"            // rgb(211, 211, 211)
	Lightgreen           = "lightgreen"           // rgb(144, 238, 144)
	Lightgrey            = "lightgrey"            // rgb(211, 211, 211)
	Lightpink            = "lightpink"            // rgb(255, 182, 193)
	Lightsalmon          = "lightsalmon"          // rgb(255, 160, 122)
	Lightseagreen        = "lightseagreen"        // rgb(32, 178, 170)
	Lightskyblue         = "lightskyblue"         // rgb(135, 206, 250)
	Lightslategray       = "lightslategray"       // rgb(119, 136, 153)
	Lightslategrey       = "lightslategrey"       // rgb(119, 136, 153)
	Lightsteelblue       = "lightsteelblue"       // rgb(176, 196, 222)
	Lightyellow          = "lightyellow"          // rgb(255, 255, 224)
	Lime                 = "lime"                 // rgb(0, 255, 0)
	Limegreen            = "limegreen"            // rgb( 50, 205, 50)
	Linen                = "linen"                // rgb(250, 240, 230)
	Magenta              = "magenta"              // rgb(255, 0, 255)
	Maroon               = "maroon"               // rgb(128, 0, 0)
	Mediumaquamarine     = "mediumaquamarine"     // rgb(102, 205, 170)
	Mediumblue           = "mediumblue"           // rgb(0, 0, 205)
	Mediumorchid         = "mediumorchid"         // rgb(186, 85, 211)
	Mediumpurple         = "mediumpurple"         // rgb(147, 112, 219)
	Mediumseagreen       = "mediumseagreen"       // rgb(60, 179, 113)
	Mediumslateblue      = "mediumslateblue"      // rgb(123, 104, 238)
	Mediumspringgreen    = "mediumspringgreen"    // rgb(0, 250, 154)
	Mediumturquoise      = "mediumturquoise"      // rgb(72, 209, 204)
	Mediumvioletred      = "mediumvioletred"      // rgb(199, 21, 133)
	Midnightblue         = "midnightblue"         // rgb(25, 25, 112)
	Mintcream            = "mintcream"            // rgb(245, 255, 250)
	Mistyrose            = "mistyrose"            // rgb(255, 228, 225)
	Moccasin             = "moccasin"             // rgb(255, 228, 181)
	Navajowhite          = "navajowhite"          // rgb(255, 222, 173)
	Navy                 = "navy"                 // rgb(0, 0, 128)
	Oldlace              = "oldlace"              // rgb(253, 245, 230)
	Olive                = "olive"                // rgb(128, 128, 0)
	Olivedrab            = "olivedrab"            // rgb(107, 142, 35)
	Orange               = "orange"               // rgb(255, 165, 0)
	Orangered            = "orangered"            // rgb(255, 69, 0)
	Orchid               = "orchid"               // rgb(218, 112, 214)
	Palegoldenrod        = "palegoldenrod"        // rgb(238, 232, 170)
	Palegreen            = "palegreen"            // rgb(152, 251, 152)
	Paleturquoise        = "paleturquoise"        // rgb(175, 238, 238)
	Palevioletred        = "palevioletred"        // rgb(219, 112, 147)
	Papayawhip           = "papayawhip"           // rgb(255, 239, 213)
	Peachpuff            = "peachpuff"            // rgb(255, 218, 185)
	Peru                 = "peru"                 // rgb(205, 133, 63)
	Pink                 = "pink"                 // rgb(255, 192, 203)
	Plum                 = "plum"                 // rgb(221, 160, 221)
	Powderblue           = "powderblue"           // rgb(176, 224, 230)
	Purple               = "purple"               // rgb(128, 0, 128)
	Red                  = "red"                  // rgb(255, 0, 0)
	Rosybrown            = "rosybrown"            // rgb(188, 143, 143)
	Royalblue            = "royalblue"            // rgb(65, 105, 225)
	Saddlebrown          = "saddlebrown"          // rgb(139, 69, 19)
	Salmon               = "salmon"               // rgb(250, 128, 114)
	Sandybrown           = "sandybrown"           // rgb(244, 164, 96)
	Seagreen             = "seagreen"             // rgb(46, 139, 87)
	Seashell             = "seashell"             // rgb(255, 245, 238)
	Sienna               = "sienna"               // rgb(160, 82, 45)
	Silver               = "silver"               // rgb(192, 192, 192)
	Skyblue              = "skyblue"              // rgb(135, 206, 235)
	Slateblue            = "slateblue"            // rgb(106, 90, 205)
	Slategray            = "slategray"            // rgb(112, 128, 144)
	Slategrey            = "slategrey"            // rgb(112, 128, 144)
	Snow                 = "snow"                 // rgb(255, 250, 250)
	Springgreen          = "springgreen"          // rgb(0, 255, 127)
	Steelblue            = "steelblue"            // rgb(70, 130, 180)
	Tan                  = "tan"                  // rgb(210, 180, 140)
	Teal                 = "teal"                 // rgb(0, 128, 128)
	Thistle              = "thistle"              // rgb(216, 191, 216)
	Tomato               = "tomato"               // rgb(255, 99, 71)
	Turquoise            = "turquoise"            // rgb(64, 224, 208)
	Violet               = "violet"               // rgb(238, 130, 238)
	Wheat                = "wheat"                // rgb(245, 222, 179)
	White                = "white"                // rgb(255, 255, 255)
	Whitesmoke           = "whitesmoke"           // rgb(245, 245, 245)
	Yellow               = "yellow"               // rgb(255, 255, 0)
	Yellowgreen          = "yellowgreen"          // rgb(154, 205, 50)
)
