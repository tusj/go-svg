// smartSVG implements svg helper functions to write good, well-formed svg in a simple fashion.
// Tags which encloses groups returns a new *SVG object which is possible to write to.
// Flush writes the coded svg to the writer provided.
package smartSVG

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"marketExchanger/helpers"
	"math"
)

const (
	svgInit = `<?xml version="1.0"?>
<!-- Generated by S-martVGo -->`
)

var defaultNamespace map[string]string

func init() {
	defaultNamespace = map[string]string{"xmlns": "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink"}
}

// Holds one svg group with nodes of children inside group.
type SVG struct {
	tag      string
	atts     map[string]string
	data     string
	comments []string
	mids     []*SVG
}

type Att struct {
	atts map[string]string
}

func (a *Att) Translate(x, y int) {
	a.atts["transform"] = a.atts["transform"] + fmt.Sprintf(" translate(%d, %d)", x, y)
}

func (a *Att) Rotate(angle float64) {
	a.atts["transform"] = a.atts["transform"] + fmt.Sprintf(" rotate(%g)", angle)
}

func (a *Att) Scale(x, y float64) {
	a.atts["transform"] = a.atts["transform"] + fmt.Sprintf(" scale(%g, %g)", x, y)
}

func (a *Att) ID(id string) {
	a.atts["id"] = id
}

// Creates child group nested from s
func (s *SVG) newGroup(tag string, attributes map[string]string) *SVG {
	g := SVG{tag: tag, atts: make(map[string]string, len(attributes))}

	// Copy map
	for k, v := range attributes {
		g.atts[k] = v
	}

	s.mids = append(s.mids, &g)
	return &g
}

// Create new SVG object to write to
func New(width, height int) *SVG {
	return &SVG{data: svgInit, mids: make([]*SVG, 0), comments: make([]string, 0), atts: map[string]string{"width": fmt.Sprint(width), "height": fmt.Sprint(height)}}
}

// Add svg group to outer svg group
func (s *SVG) Add(svg *SVG) {
	s.mids = append(s.mids, svg)
}

// Flush svg in order to write the SVG
func (s *SVG) Flush(w io.Writer) error {
	if s.tag != "" {
		return errors.New("I will only write from the outermost svg element")
	}
	s.tag = "svg"
	for k, v := range defaultNamespace {
		s.atts[k] = v
	}

	var writeGroupPtr func(*SVG, int)
	writeGroup := func(s *SVG, level int) {
		tabs := bytes.Repeat([]byte("\t"), level)

		// Encode attributes to form att1="val1" att2="val2"... 
		buf := bytes.NewBuffer(nil)
		for k, v := range s.atts {
			fmt.Fprintf(buf, `%s="%v" `, k, v)
		}

		atts := buf.Bytes()
		if len(atts) > 0 { // Remove superfluous space
			atts = atts[:len(atts)-1]
		}

		for _, v := range s.comments {
			w.Write([]byte("<!--" + v + "-->\n"))
		}
		
		w.Write(tabs)
		w.Write([]byte("<" + s.tag))
		if len(atts) != 0 {
			w.Write([]byte(" "))
		}
		w.Write(atts)
		
		switch {
		case len(s.mids) == 0 && len(s.data) == 0:
			w.Write([]byte(" />\n"))
		case len(s.mids) != 0:
			w.Write([]byte(">\n"))
			for _, v := range s.mids {
				writeGroupPtr(v, level+1)
			}
			w.Write(tabs)
			w.Write([]byte("</" + s.tag + ">\n"))
		default:
			w.Write([]byte(">" + s.data + "</" + s.tag + ">\n"))
		}
	}
	writeGroupPtr = writeGroup
	writeGroup(s, 0)
	return nil
}

func (s *SVG) AddAtt(atts map[string]string) {
	for k, v := range atts {
		s.atts[k] = v
	}
}

// Write Start. Ref http://www.w3.org/TR/SVG11/struct.html#SVGElement
func (s *SVG) Start(width, height int, atts map[string]string) *SVG {
	g := s.newGroup("svg", atts)
	g.atts["width"] = fmt.Sprint(width)
	g.atts["height"] = fmt.Sprint(height)
	return g
}

// Start with viewbox. 
func (s *SVG) StartView(width, height, minX, minY, viewWidth, viewHeight int, atts map[string]string) *SVG {
	g := s.Start(width, height, atts)
	g.atts["viewBox"] = fmt.Sprintf("%d %d %d %d", minX, minY, viewWidth, viewHeight)
	return g
}

func (s *SVG) Symbol(id string, atts map[string]string) *SVG {
	g := s.newGroup("symbol", atts)
	g.atts["id"] = id
	return g
}

func (s *SVG) SymbolWithViewbox(id string, minX, minY, viewWidth, viewHeight int, atts map[string]string) *SVG {
	g := s.Symbol(id, atts)
	g.atts["viewBox"] = fmt.Sprintf("%d %d %d %d", minX, minY, viewWidth, viewHeight)
	return g
}

func (s *SVG) Use(id string, atts map[string]string) *SVG {
	g := s.newGroup("use", atts)
	g.atts["xlink:href"] = "#" + id
	return g
}

func (s *SVG) Comment(comment string) {
	s.comments = append(s.comments, comment)
}

// Create title
func (s *SVG) Title(title string) *SVG {
	g := s.newGroup("title", nil)
	g.data = title
	return g
}

// Create description
func (s *SVG) Desc(description string) *SVG {
	g := s.newGroup("desc", nil)
	g.data = description
	return g
}

// Create definitions
func (s *SVG) Def() *SVG {
	return s.newGroup("defs", nil)
}

// Create marker
func (s *SVG) Marker(id string, atts map[string]string) *SVG {
	g := s.newGroup("marker", atts)
	g.atts["id"] = id
	return g
}

// Create group
func (s *SVG) G(atts map[string]string) *SVG {
	return s.newGroup("g", atts)
}

// Create group with id
func (s *SVG) GID(id string, atts map[string]string) *SVG {
	g := s.G(atts)
	g.atts["id"] = id
	return g
}

// Translate coordinate system
func (s *SVG) Translate(x, y int) *SVG {
	atts := map[string]string{"transform": fmt.Sprintf("translate(%d, %d)", x, y)}
	return s.newGroup("g", atts)
}

// Scale coordinate system
func (s *SVG) Scale(x, y float64) *SVG {
	atts := map[string]string{"transform": fmt.Sprintf("scale(%g, %g)", x, y)}
	return s.newGroup("g", atts)
}

// Draw circle
func (s *SVG) Circle(x, y, r int, atts map[string]string) *SVG {
	g := s.newGroup("circle", atts)
	g.atts["cx"] = fmt.Sprint(x)
	g.atts["cy"] = fmt.Sprint(y)
	g.atts["r"] = fmt.Sprint(r)
	return g
}

// Draw rectangle
func (s *SVG) Rect(x, y, width, height int, atts map[string]string) *SVG {
	g := s.newGroup("rect", atts)
	g.atts["x"] = fmt.Sprint(x)
	g.atts["y"] = fmt.Sprint(y)
	g.atts["width"] = fmt.Sprint(width)
	g.atts["height"] = fmt.Sprint(height)
	return g
}

// Draw line
func (s *SVG) Line(x1, y1, x2, y2 int, atts map[string]string) *SVG {
	g := s.newGroup("line", atts)
	g.atts["x1"] = fmt.Sprint(x1)
	g.atts["x2"] = fmt.Sprint(x2)
	g.atts["y1"] = fmt.Sprint(y1)
	g.atts["y2"] = fmt.Sprint(y2)
	return g
}

// Draw polyline
func (s *SVG) Polyline(x, y []float64, atts map[string]string) (error, *SVG) {
	switch {
	case len(x) != len(y):
		return errors.New("length of x and y data is not equal"), nil
	case len(x) == 0:
		return errors.New("length of x is zero"), nil
	}

	encloseData := func(x, y float64) string {
		return fmt.Sprintf("%f, %f ", x, y)
	}

	data := make([]byte, 0, len(x)*4)
	for i := range x {
		data = append(data, []byte(encloseData(x[i], y[i]))...)
	}

	g := s.newGroup("polyline", atts)
	g.atts["points"] = string(data)
	return nil, g
}

// Draw text
func (s *SVG) Text(x, y int, text string, atts map[string]string) *SVG {
	g := s.newGroup("text", atts)
	g.data = text
	g.atts["x"] = fmt.Sprint(x)
	g.atts["y"] = fmt.Sprint(y)

	return g
}

const (
	verticalShift = iota
	horizontalShift
)

func findShiftAndScale(i []float64, length int) (scale, shift float64, err error) {
	switch {
	case i == nil:
		err = errors.New("Received invalid argument: Argument is nil")
	case len(i) == 0:
		err = errors.New("Received invalid argument: Argument is zero")
	}
	if err != nil {
		return
	}
	Max, Min := helpers.Max(i), helpers.Min(i)
	
	scale = float64(length*90/100) / (Max[0] - Min[0])
	shift = -Min[0]
	return
}

func shiftAndScale(i []float64, shift, scale float64) (scaled []int) {
	scaled = make([]int, len(i))

	for ind, v := range i {
		scaled[ind] = int(helpers.Round((v+shift)*scale, 0))
	}

	return
}

// Write text for diagrams from p1 to p2, with cntGrids indicators.
func (s *SVG) Label(x1, y1, x2, y2 int, vals []float64, cntGrids int, atts map[string]string) {
	g := s.GID("label", atts)
	xDiff := float64(x2 - x1)
	yDiff := float64(y2 - y1)
	angle := math.Atan(yDiff / xDiff)
	
	valIncr := (vals[len(vals)-1] - vals[0]) / float64(cntGrids)
	xIncr := float64(xDiff) / float64(cntGrids) * math.Cos(angle)
	yIncr := float64(yDiff) / float64(cntGrids) * math.Sin(angle)
	
	val := vals[0]
	x := float64(x1)
	y := float64(y1)
	for i := 0; i < cntGrids; i++ {
		g.Text(int(helpers.Round(x, 0)), int(helpers.Round(y, 0)), fmt.Sprintf("%.2f", val), nil)
		val += valIncr
		x += xIncr
		y += yIncr
	}
}

// Paint a diagram. Prerequisites: X must be sorted.
func (s *SVG) Diagram(width, height int, xVals, yVals []float64) (error, *SVG) {

	if len(xVals) != len(yVals) {
		return errors.New("Got data pair with inconsistent length. Len x: " + fmt.Sprint(len(xVals)) + "\tlen y: " + fmt.Sprint(len(xVals))), nil
	}

	minWidth, minHeight := 100, 100

	switch {
	case width < 100:
		return errors.New("Width is below minimum width, which is " + fmt.Sprint(minWidth)), nil
	case height < 100:
		return errors.New("Height is below minimum height, which is " + fmt.Sprint(minHeight)), nil
	}

	textRoom := 70
	cntGrids := 10
	dWidth, dHeight := width-textRoom, height-textRoom
	v := s.Start(width, height, nil)
	v.AddAtt(map[string]string{"id": "diagram"})
	v.Label(textRoom/2, 0, textRoom/2, height - textRoom, yVals, cntGrids, nil)
	v.Label(textRoom, height - 2 * textRoom / 3, width, height- 2 * textRoom / 3, xVals, cntGrids, nil)
	defer v.Rect(0, 0, width, height, map[string]string{"stroke": "grey", "stroke-width": "2", "fill": "none"})
	g := v.GID("plot", map[string]string{"transform": fmt.Sprintf("translate(%d, %d)", textRoom, 0)})
	d := g.StartView(dWidth, dHeight, 0, 0, dWidth, dHeight, map[string]string{"id": "plot", "preserveAspectRatio": "xMinyMax meet"})
	defer d.Rect(0, 0, dWidth, dHeight, map[string]string{"stroke": "grey", "stroke-width": "1", "fill": "none"})
	//d.Grid(0, 0, dWidth, dHeight, cntGrids, map[string]string{"stroke": "grey", "stroke-width": "1"})
	d.Def().Marker("polyline-midmarker", map[string]string{"style": "overflow:visible", "fill": "black"}).Circle(0, 0, 2, map[string]string{"fill": "none", "stroke": "black"})
	
	d.AddAtt(map[string]string{"presereveAspectRatio": "xMaxYMin middle"})
	i := d.Scale(1, -1)
	j := i.G(map[string]string{"fill": "none", "stroke": "red", "stroke-width": "1"})
	err, k := j.Polyline(xVals, yVals, nil)
	return err, k
	//xShifts := make([]float64, len(vals))
	//yShifts := make([]float64, len(vals))
	//xScales := make([]float64, len(vals))
	//yScales := make([]float64, len(vals))

	//for i, xyPair := range vals {
	//xShifts[i], xScales[i], err = findShiftAndScale(xyPair[0], width)
	//if err != nil {
	//return
	//}

	//yShifts[i], yScales[i], err = findShiftAndScale(xyPair[1], height)
	//if err != nil {
	//return
	//}
	//}

	//scales := helpers.Min(xScales, yScales)
	//shifts := helpers.Min(xShifts, yShifts)

	//l := d.Scale(1, -1).G(`fill="none"`)
	//for _, xyPair := range vals {
	//xScales := shiftAndScale(xyPair[0], scales[0],shifts[0])
	//yScales := shiftAndScale(xyPair[1], scales[1], shifts[1])
	//l.PolyLine(xScales, yScales)
	//}
}

func (s *SVG) Grid(x, y, width, height, cntGrids int, atts map[string]string) {
	g := s.GID("grid", atts)
	d := g.Def()

	vLine := "vLine"
	hLine := "hLine"
	d.GID(vLine, nil).Line(0, 0, 0, height, nil)
	d.GID(hLine, nil).Line(0, 0, width, 0, nil)

	gridSizeX := float64(width) / float64(cntGrids)
	gridSizeY := float64(height) / float64(cntGrids)

	for ix := float64(x); ix <= float64(x+width); ix += gridSizeX {
		g.Use(vLine, map[string]string{"x": fmt.Sprintf("%.0f", ix)})
	}

	for iy := float64(y); iy <= float64(y+height); iy += gridSizeY {
		g.Use(hLine, map[string]string{"y": fmt.Sprintf("%.0f", iy)})
	}
}